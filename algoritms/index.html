<!DOCTYPE html>
<html>
<head>
  <title>Interactive p5.js Drawing with Dice Rolls</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #f0f0f0;
    }
    #dice {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    .dice {
      width: 50px;
      height: 50px;
      font-size: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 2px solid #000;
      margin: 0 10px;
    }
  </style>
</head>
<body>
  <div id="dice">
    <div class="dice" id="dice1">0</div>
    <div class="dice" id="dice2">0</div>
  </div>
  <script>
    let startX = 60; // Initial starting x coordinate
    let startY = 0;  // Initial starting y coordinate
    let points = [[startX, startY]];
    let moveCount = 0;
    let currentDirection = 1;
    let numMovesPerLine = 15; // Change the number of steps per line to 15
    let lineSpacing = 20;
    let canvasWidth = 800; // Define canvas width
    let canvasHeight = 600; // Define canvas height
    let dice1, dice2;

    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      background(255);
      stroke(0);
      fill(0);

      // Select dice elements
      dice1 = select('#dice1');
      dice2 = select('#dice2');
    }

    function draw() {
      // No continuous drawing needed
      noLoop();
    }

    function rollDice() {
      return int(random(1, 7));
    }

    function mousePressed() {
      // Continue drawing until the last starting point is reached
      if (startX < canvasWidth - 6) {
        // Roll the dice
        let stepsDown = rollDice();
        let stepsHorizontal = rollDice();

        // Update dice display
        dice1.html(stepsDown);
        dice2.html(stepsHorizontal);

        // Calculate new position
        if (moveCount % 2 === 0) { // Odd moves (to the right)
          startX += stepsHorizontal * 10 * currentDirection;
        } else { // Even moves (to the left)
          startX -= stepsHorizontal * 10 * currentDirection;
        }
        startY += stepsDown * 10;

        // Add new point
        let newPoint = [startX, startY];
        points.push(newPoint);

        // Draw the line with stylized brush stroke
        let strokeWeightRandom = random(1, 3); // Randomize stroke weight within range
        let opacityRandom = random(50, 150); // Randomize opacity
        let alpha = map(opacityRandom, 50, 150, 50, 200); // Map opacity to alpha value
        strokeWeight(strokeWeightRandom); // Set the stroke weight
        stroke(0, alpha); // Set the stroke color with transparency
        if (points.length > 1) {
          let prevPoint = points[points.length - 2];
          line(prevPoint[0], prevPoint[1], newPoint[0], newPoint[1]);
        }

        // Increment move count
        moveCount++;

        // Reset for new line if needed
        if (moveCount >= numMovesPerLine) {
          moveCount = 0;
          startX = points[0][0] + lineSpacing;
          startY = 0;
          points = [[startX, startY]];
          currentDirection *= -1; // Alternate direction
        }
      } else {
        // Restart the drawing
        startX = 60; // Reset starting x coordinate
        startY = 0;  // Reset starting y coordinate
        points = [[startX, startY]]; // Reset points array
        moveCount = 0; // Reset move count
        redraw(); // Redraw the canvas
      }
    }
  </script>
</body>
</html>
